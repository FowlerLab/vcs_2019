% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiBatchNorm.R
\name{multiBatchNorm}
\alias{multiBatchNorm}
\title{Per-batch scaling normalization}
\usage{
multiBatchNorm(..., assay.type = "counts", norm.args = list(),
  min.mean = 1, subset.row = NULL, separate.spikes = FALSE)
}
\arguments{
\item{...}{Two or more \linkS4class{SingleCellExperiment} objects containing counts and size factors.
Each object is assumed to represent one batch.}

\item{assay.type}{A string specifying which assay values contains the counts.}

\item{norm.args}{A named list of further arguments to pass to \code{\link[scater]{normalize}}.}

\item{min.mean}{A numeric scalar specifying the minimum (library size-adjusted) average count of genes to be used for normalization.}

\item{subset.row}{A vector specifying which features to use for correction.}

\item{separate.spikes}{Logical scalar indicating whether spike-in size factors should be rescaled separately from endogenous genes.}
}
\value{
A list of SingleCellExperiment objects with normalized log-expression values in the \code{"logcounts"} assay (depending on values in \code{norm.args}).
}
\description{
Perform scaling normalization within each batch to provide comparable results to the lowest-coverage batch.
}
\details{
When performing integrative analyses of multiple batches, it is often the case that different batches have large differences in coverage.
This function removes systematic differences in coverage across batches to simplify downstream comparisons.
It does so by resaling the size factors using median-based normalization on the ratio of the average counts between batches.
This is roughly equivalent to the between-cluster normalization described by Lun et al. (2016).

This function will adjust the size factors so that counts in high-coverage batches are scaled \emph{downwards} to match the coverage of the most shallow batch.
The \code{\link[scater]{normalize}} function will then add the same pseudo-count to all batches before log-transformation.
By scaling downwards, we favour stronger squeezing of log-fold changes from the pseudo-count, mitigating any technical differences in variance between batches.
Of course, genuine biological differences will also be shrunk, but this is less of an issue for upregulated genes with large counts.

This function is preferred over running \code{\link{normalize}} directly when computing log-normalized values for use in \code{\link{mnnCorrect}} or \code{\link{fastMNN}}.
In most cases, size factors will be computed within each batch;
their direct application in \code{\link{normalize}} will not account for scaling differences between batches.
In contrast, \code{multiBatchNorm} will rescale the size factors so that they are comparable across batches.

Only genes with library size-adjusted average counts greater than \code{min.mean} will be used for computing the rescaling factors.
This improves precision and avoids problems with discreteness.
Users can also set \code{subset.row} to restrict the set of genes used for computing the rescaling factors.
However, this only affects the rescaling of the size factors - normalized values for \emph{all} genes will still be returned.
}
\section{Handling spike-ins}{

Spike-in transcripts should be either absent in all batches or, if present, they should be the same across all batches.
Rows annotated as spike-in transcripts are not used to compute the rescaling factors for endogenous genes.

By default, the spike-in size factors are rescaled using the same scaling factor for the endogenous genes in the same batch.
This preserves the abundances of the spike-in transcripts relative to the endogenous genes, 
which is important if the returned SingleCellExperiments are to be used to model technical noise.

If \code{separate.spikes=TRUE}, spike-in size factors are rescaled separately from those of the endogenous genes.
This will eliminate differences in spike-in quantities across batches at the cost of losing the ability to compare between endogenous and spike-in transcripts within each batch.
}

\examples{
d1 <- matrix(rnbinom(50000, mu=10, size=1), ncol=100)
sce1 <- SingleCellExperiment(list(counts=d1))
sizeFactors(sce1) <- runif(ncol(d1))

d2 <- matrix(rnbinom(20000, mu=50, size=1), ncol=40)
sce2 <- SingleCellExperiment(list(counts=d2))
sizeFactors(sce2) <- runif(ncol(d2))

out <- multiBatchNorm(sce1, sce2)
summary(sizeFactors(out[[1]]))
summary(sizeFactors(out[[2]]))

}
\references{
Lun ATL, Bach K and Marioni JC (2016).
Pooling across cells to normalize single-cell RNA sequencing data with many zero counts.
\emph{Genome Biol.} 17:75
}
\seealso{
\code{\link{mnnCorrect}} and \code{\link{fastMNN}} for methods that can benefit from rescaling.

\code{\link[scater]{normalize}} for the calculation of log-transformed normalized expression values.
}
\author{
Aaron Lun
}
